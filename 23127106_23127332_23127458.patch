diff --git a/Makefile b/Makefile
index 74e454f..24e6309 100644
--- a/Makefile
+++ b/Makefile
@@ -194,7 +194,10 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
-
+	$U/_pingpong\
+	$U/_primes\
+	$U/_find\
+	$U/_xargs\
 
 
 
diff --git a/user/find.c b/user/find.c
new file mode 100644
index 0000000..5dcdc91
--- /dev/null
+++ b/user/find.c
@@ -0,0 +1,74 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+#include "kernel/fcntl.h"
+
+char* trim_file_name(char *path) {
+  char *p;
+
+  // Find first character after last slash.
+  for(p=path+strlen(path); p >= path && *p != '/'; p--)
+    ;
+  p++;
+
+  return p;
+}
+
+void find(char* path, char* file_name) {
+    
+    char buf[512], *p;
+    int fd;
+    struct dirent de;
+    struct stat st;
+
+    if ((fd = open(path, O_RDONLY)) < 0) {
+        fprintf(2, "find: cannot open %s\n", path);
+        return;
+    }
+     
+    if (fstat(fd, &st) < 0) {
+        fprintf(2, "find: cannot stat %s\n", path);
+        close(fd);
+        return;
+    }
+
+    switch(st.type) {
+        case T_DEVICE:
+        case T_FILE:
+            if (strcmp(trim_file_name(path), file_name) == 0) printf("%s\n", path);
+            break;
+        case T_DIR:
+            if(strlen(path) + 1 + DIRSIZ + 1 > sizeof buf){
+                printf("find: path too long\n");
+                break;
+            }
+            strcpy(buf, path);
+            p = buf+strlen(buf);
+            *p++ = '/';
+            while(read(fd, &de, sizeof(de)) == sizeof(de)){
+                if(de.inum == 0)
+                    continue;
+                if (strcmp(de.name, ".") == 0 || strcmp(de.name, "..") == 0) continue;
+                memmove(p, de.name, DIRSIZ);
+                p[DIRSIZ] = 0;
+                find(buf, file_name);
+            }
+            break;
+    }
+    close(fd);
+    return;
+}
+
+int main(int argc, char *argv[]) {
+
+  if(argc < 3){
+    printf("Missing arguments\n");
+    exit(1);
+  }
+
+  
+
+  find(argv[1], argv[2]);
+  exit(0);
+}
diff --git a/user/pingpong.c b/user/pingpong.c
new file mode 100644
index 0000000..0bfea0a
--- /dev/null
+++ b/user/pingpong.c
@@ -0,0 +1,66 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+int main(int argc, char *argv[]) {
+
+    int p_parent[2];
+    int p_child[2];
+    char buffer[100];
+
+    pipe(p_parent); //Parent writes and child reads
+    pipe(p_child); //Child writes and parent reads
+
+    int pid = fork();
+
+    if (pid == 0) {
+        //Child process
+        close(p_parent[1]);
+        close(p_child[0]);
+
+        if (read(p_parent[0], buffer, 1) != 1) {
+            printf("%d: child read error\n", getpid());
+            exit(1);
+        }
+
+        printf("%d: received ping\n", getpid());
+        
+        if (write(p_child[1], "c", 1) != 1) {
+            printf("%d: child write error\n", getpid());
+        }
+
+        close(p_parent[0]);
+        close(p_child[1]);
+        exit(0);
+
+    } else if (pid > 0) {
+        //Parent process
+        close(p_parent[0]);
+        close(p_child[1]);
+
+        if (write(p_parent[1], "c", 1) != 1) {
+            printf("%d: parent write error\n", getpid());
+            exit(1);
+        }
+
+        wait((int*)0);
+
+        if (read(p_child[0], buffer, 1) != 1) {
+            printf("%d: parent read error\n", getpid());
+            exit(1);
+        }
+        
+        printf("%d: received pong\n", getpid());
+
+        close(p_parent[1]);
+        close(p_child[0]);
+        
+        exit(0);
+        
+    } else {
+        printf("Fork error!\n");
+        exit(1);
+    }
+
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/primes.c b/user/primes.c
new file mode 100644
index 0000000..a653d05
--- /dev/null
+++ b/user/primes.c
@@ -0,0 +1,67 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+void primes(int) __attribute__((noreturn));
+
+void primes(int left_p) {
+    int num;
+    int prime;
+    int right_p[2];
+
+    //Read first number (must be a prime) of the process
+    if (read(left_p, &prime, sizeof(int)) != sizeof(int)) {
+        //This process does not receive any number, exit
+        close(left_p);
+        exit(0);
+    }
+    printf("prime %d\n", prime);
+
+    pipe(right_p);
+
+    int pid = fork();
+
+    if (pid == 0) {
+        close(left_p);
+        close(right_p[1]);
+        primes(right_p[0]);
+    } else if (pid > 0) {
+        close(right_p[0]);
+        while (read(left_p, &num, sizeof(int)) != 0) {
+            if (num % prime != 0) write(right_p[1], &num, sizeof(int));
+        }
+        close(left_p);
+        close(right_p[1]);
+        wait(0);
+        exit(0);
+    } else {
+        printf("Fork error\n");
+        exit(1);
+    }
+
+}
+
+int main(int argc, char *argv[]) {
+    
+    int main_p[2];
+    pipe(main_p);
+
+    int pid = fork();
+
+    if (pid == 0) {
+        close(main_p[1]);
+        primes(main_p[0]);
+    } else if (pid > 0) {
+        close(main_p[0]);
+        for (int i = 2; i <= 280; ++i) {
+            write(main_p[1], &i, sizeof(int));
+        }
+        close(main_p[1]);
+        wait(0);
+    } else {
+        printf("Fork error\n");
+        exit(1);
+    }
+
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/xargs.c b/user/xargs.c
new file mode 100644
index 0000000..4b247da
--- /dev/null
+++ b/user/xargs.c
@@ -0,0 +1,92 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+#include "kernel/fcntl.h"
+#include "kernel/param.h"
+
+#define MAXLINE 512
+
+int main(int argc, char *argv[]) {
+    char buf[MAXLINE];
+    int pos, r;
+    char c;
+
+    if (argc < 2) {
+        printf("xargs: Missing arguments\n");
+        exit(1);
+    }
+
+    while (1) {
+        pos = 0;
+
+        //Read a line
+        while (1) {
+            r = read(0, &c, 1);
+
+            if (r < 0) {
+                printf("xargs: Input error\n");
+                exit(1);
+            }
+
+            if (r == 0) break; //EOF
+            if (c == '\n') break;
+
+            if (pos < MAXLINE-1) buf[pos++] = c;
+        }
+
+        if (r == 0 && pos == 0) break; //EOF and no character read
+
+        buf[pos] = '\0'; //Line termination
+
+        //Build new args array
+        char* args[MAXARG];
+        int arg_count = 0;
+        //Note: argv[0] = "xargs"
+        for (int i = 1; i < argc; ++i) {
+            args[arg_count++] = argv[i];
+        }
+
+        //Parse line buf into args
+        int i = 0;
+        while (buf[i]) {
+            if (buf[i] == ' ' || buf[i] == '\t') ++i;
+            if (buf[i] == '\0') break;
+
+            args[arg_count++] = &buf[i];
+            if (arg_count >= MAXARG-1) {
+                printf("xargs: Too many arguments\n");
+                exit(1);
+            }
+
+            while (buf[i] && buf[i] != ' ' && buf[i] != '\t') ++i;
+            if (buf[i]) {
+                buf[i] = '\0';
+                ++i;
+            }
+        } 
+
+        args[arg_count] = 0; //Null-terminate the args array
+
+        //Fork child and execute command
+        int pid = fork();
+
+        if (pid < 0) {
+            printf("xargs: Fork error\n");
+            exit(1);
+        }
+
+        if (pid == 0) {
+            //Child process
+            exec(args[0], args);
+            //exec return: failed
+            printf("xargs: exec failed\n");
+            exit(1);
+        }
+
+        wait(0); //Parent wait child
+
+    }
+
+    exit(0);
+}
\ No newline at end of file
